/* menubar.c generated by valac 0.20.1, the Vala compiler
 * generated from menubar.vala, do not modify */

/* -*- Mode: Vala; indent-tabs-mode: nil; tab-width: 4 -*-
 *
 * Copyright (C) 2011,2012 Canonical Ltd
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authors: Robert Ancell <robert.ancell@canonical.com>
 *          Michael Terry <michael.terry@canonical.com>
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include "libindicator/indicator.h"
#include "libindicator/indicator-desktop-shortcuts.h"
#include "libindicator/indicator-image-helper.h"
#include "libindicator/indicator-object.h"
#include "libindicator/indicator-service.h"
#include "libindicator/indicator-service-manager.h"
#include <atk/atk.h>
#include <stdlib.h>
#include <string.h>
#include <cairo.h>
#include <float.h>
#include <math.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <gio/gio.h>
#include "config.h"
#include <glib/gi18n-lib.h>
#include <gdk/gdk.h>
#include "libindicator/indicator-ng.h"
#include <stdio.h>
#include <gtk/gtkx.h>
#include <sys/utsname.h>


#define TYPE_INDICATOR_MENU_ITEM (indicator_menu_item_get_type ())
#define INDICATOR_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_INDICATOR_MENU_ITEM, IndicatorMenuItem))
#define INDICATOR_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_INDICATOR_MENU_ITEM, IndicatorMenuItemClass))
#define IS_INDICATOR_MENU_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_INDICATOR_MENU_ITEM))
#define IS_INDICATOR_MENU_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_INDICATOR_MENU_ITEM))
#define INDICATOR_MENU_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_INDICATOR_MENU_ITEM, IndicatorMenuItemClass))

typedef struct _IndicatorMenuItem IndicatorMenuItem;
typedef struct _IndicatorMenuItemClass IndicatorMenuItemClass;
typedef struct _IndicatorMenuItemPrivate IndicatorMenuItemPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_MENU_BAR (menu_bar_get_type ())
#define MENU_BAR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MENU_BAR, MenuBar))
#define MENU_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MENU_BAR, MenuBarClass))
#define IS_MENU_BAR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MENU_BAR))
#define IS_MENU_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MENU_BAR))
#define MENU_BAR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MENU_BAR, MenuBarClass))

typedef struct _MenuBar MenuBar;
typedef struct _MenuBarClass MenuBarClass;
typedef struct _MenuBarPrivate MenuBarPrivate;

#define TYPE_BACKGROUND (background_get_type ())
#define BACKGROUND(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BACKGROUND, Background))
#define BACKGROUND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_BACKGROUND, BackgroundClass))
#define IS_BACKGROUND(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BACKGROUND))
#define IS_BACKGROUND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_BACKGROUND))
#define BACKGROUND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_BACKGROUND, BackgroundClass))

typedef struct _Background Background;
typedef struct _BackgroundClass BackgroundClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))

#define BACKGROUND_TYPE_DRAW_FLAGS (background_draw_flags_get_type ())
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
#define _g_variant_builder_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_builder_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _fclose0(var) ((var == NULL) ? NULL : (var = (fclose (var), NULL)))

#define TYPE_UNITY_GREETER (unity_greeter_get_type ())
#define UNITY_GREETER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_UNITY_GREETER, UnityGreeter))
#define UNITY_GREETER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_UNITY_GREETER, UnityGreeterClass))
#define IS_UNITY_GREETER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_UNITY_GREETER))
#define IS_UNITY_GREETER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_UNITY_GREETER))
#define UNITY_GREETER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_UNITY_GREETER, UnityGreeterClass))

typedef struct _UnityGreeter UnityGreeter;
typedef struct _UnityGreeterClass UnityGreeterClass;
typedef struct _UnityGreeterPrivate UnityGreeterPrivate;

struct _IndicatorMenuItem {
	GtkMenuItem parent_instance;
	IndicatorMenuItemPrivate * priv;
	IndicatorObjectEntry* entry;
};

struct _IndicatorMenuItemClass {
	GtkMenuItemClass parent_class;
};

struct _IndicatorMenuItemPrivate {
	GtkBox* hbox;
};

struct _MenuBar {
	GtkMenuBar parent_instance;
	MenuBarPrivate * priv;
};

struct _MenuBarClass {
	GtkMenuBarClass parent_class;
};

struct _MenuBarPrivate {
	Background* _background;
	gboolean _high_contrast;
	GtkWindow* _keyboard_window;
	GtkAccelGroup* _accel_group;
	gchar* default_theme_name;
	GList* indicator_objects;
	GtkCheckMenuItem* high_contrast_item;
	GPid keyboard_pid;
	GPid reader_pid;
	GtkCheckMenuItem* onscreen_keyboard_item;
};

typedef enum  {
	BACKGROUND_DRAW_FLAGS_NONE,
	BACKGROUND_DRAW_FLAGS_GRID
} BackgroundDrawFlags;

struct _UnityGreeter {
	GTypeInstance parent_instance;
	volatile int ref_count;
	UnityGreeterPrivate * priv;
	gboolean test_mode;
	gboolean orca_needs_kick;
};

struct _UnityGreeterClass {
	GTypeClass parent_class;
	void (*finalize) (UnityGreeter *self);
};


static gpointer indicator_menu_item_parent_class = NULL;
static gpointer menu_bar_parent_class = NULL;
extern UnityGreeter* unity_greeter_singleton;

GType indicator_menu_item_get_type (void) G_GNUC_CONST;
#define INDICATOR_MENU_ITEM_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_INDICATOR_MENU_ITEM, IndicatorMenuItemPrivate))
enum  {
	INDICATOR_MENU_ITEM_DUMMY_PROPERTY
};
IndicatorMenuItem* indicator_menu_item_new (IndicatorObjectEntry* entry);
IndicatorMenuItem* indicator_menu_item_construct (GType object_type, IndicatorObjectEntry* entry);
void indicator_menu_item_visibility_changed_cb (IndicatorMenuItem* self, GtkWidget* widget);
static void _indicator_menu_item_visibility_changed_cb_gtk_widget_show (GtkWidget* _sender, gpointer self);
static void _indicator_menu_item_visibility_changed_cb_gtk_widget_hide (GtkWidget* _sender, gpointer self);
gboolean indicator_menu_item_has_visible_child (IndicatorMenuItem* self);
static void indicator_menu_item_finalize (GObject* obj);
GType menu_bar_get_type (void) G_GNUC_CONST;
GType background_get_type (void) G_GNUC_CONST;
#define MENU_BAR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_MENU_BAR, MenuBarPrivate))
enum  {
	MENU_BAR_DUMMY_PROPERTY,
	MENU_BAR_BACKGROUND,
	MENU_BAR_HIGH_CONTRAST,
	MENU_BAR_KEYBOARD_WINDOW,
	MENU_BAR_ACCEL_GROUP
};
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
#define MENU_BAR_HEIGHT 24
MenuBar* menu_bar_new (Background* bg, GtkAccelGroup* ag);
MenuBar* menu_bar_construct (GType object_type, Background* bg, GtkAccelGroup* ag);
static gboolean menu_bar_real_draw (GtkWidget* base, cairo_t* c);
Background* menu_bar_get_background (MenuBar* self);
GType background_draw_flags_get_type (void) G_GNUC_CONST;
void background_draw_full (Background* self, cairo_t* c, BackgroundDrawFlags flags);
void menu_bar_set_keyboard_state (MenuBar* self);
gboolean ug_settings_get_boolean (const gchar* key);
#define UG_SETTINGS_KEY_ONSCREEN_KEYBOARD "onscreen-keyboard"
static void menu_bar_close_pid (MenuBar* self, GPid* pid);
void menu_bar_cleanup (MenuBar* self);
static void menu_bar_real_get_preferred_height (GtkWidget* base, gint* min, gint* nat);
static void menu_bar_greeter_set_env (MenuBar* self, const gchar* key, const gchar* val);
static GtkWidget* menu_bar_make_a11y_indicator (MenuBar* self);
static void menu_bar_keyboard_toggled_cb (MenuBar* self, GtkCheckMenuItem* item);
static void _menu_bar_keyboard_toggled_cb_gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self);
static void menu_bar_high_contrast_toggled_cb (MenuBar* self, GtkCheckMenuItem* item);
static void _menu_bar_high_contrast_toggled_cb_gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self);
GtkAccelGroup* menu_bar_get_accel_group (MenuBar* self);
#define UG_SETTINGS_KEY_HIGH_CONTRAST "high-contrast"
static void menu_bar_screen_reader_toggled_cb (MenuBar* self, GtkCheckMenuItem* item);
static void _menu_bar_screen_reader_toggled_cb_gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self);
#define UG_SETTINGS_KEY_SCREEN_READER "screen-reader"
static IndicatorObject* menu_bar_load_indicator_file (MenuBar* self, const gchar* indicator_name);
static IndicatorObject* menu_bar_load_indicator_library (MenuBar* self, const gchar* indicator_name);
static void menu_bar_load_indicator (MenuBar* self, const gchar* indicator_name);
static void menu_bar_indicator_added_cb (MenuBar* self, IndicatorObject* object, IndicatorObjectEntry* entry);
static void _menu_bar_indicator_added_cb_indicator_object_entry_added (IndicatorObject* _sender, IndicatorObjectEntry* entry, gpointer self);
static void menu_bar_indicator_removed_cb (MenuBar* self, IndicatorObject* object, IndicatorObjectEntry* entry);
static void _menu_bar_indicator_removed_cb_indicator_object_entry_removed (IndicatorObject* _sender, IndicatorObjectEntry* entry, gpointer self);
static void menu_bar_setup_indicators (MenuBar* self);
gchar** ug_settings_get_strv (const gchar* key, int* result_length1);
#define UG_SETTINGS_KEY_INDICATORS "indicators"
gboolean ug_settings_set_strv (const gchar* key, gchar** value, int value_length1);
static gint __lambda34_ (IndicatorObject* a, IndicatorObject* b);
static gint ___lambda34__gcompare_func (gconstpointer a, gconstpointer b);
gboolean ug_settings_set_boolean (const gchar* key, gboolean value);
GtkWindow* menu_bar_get_keyboard_window (MenuBar* self);
static void menu_bar_set_keyboard_window (MenuBar* self, GtkWindow* value);
static void menu_bar_set_high_contrast (MenuBar* self, gboolean value);
gboolean menu_bar_get_high_contrast (MenuBar* self);
gpointer unity_greeter_ref (gpointer instance);
void unity_greeter_unref (gpointer instance);
GParamSpec* param_spec_unity_greeter (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_unity_greeter (GValue* value, gpointer v_object);
void value_take_unity_greeter (GValue* value, gpointer v_object);
gpointer value_get_unity_greeter (const GValue* value);
GType unity_greeter_get_type (void) G_GNUC_CONST;
static gboolean ____lambda33_ (MenuBar* self);
static gboolean _____lambda33__gsource_func (gpointer self);
static guint menu_bar_get_indicator_index (MenuBar* self, IndicatorObject* object);
static IndicatorObject* menu_bar_get_indicator_object_from_entry (MenuBar* self, IndicatorObjectEntry* entry);
static void menu_bar_set_background (MenuBar* self, Background* value);
static void menu_bar_set_accel_group (MenuBar* self, GtkAccelGroup* value);
static GObject * menu_bar_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void _menu_bar_cleanup_unity_greeter_starting_session (UnityGreeter* _sender, gpointer self);
static void menu_bar_finalize (GObject* obj);
static void _vala_menu_bar_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_menu_bar_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static void _indicator_menu_item_visibility_changed_cb_gtk_widget_show (GtkWidget* _sender, gpointer self) {
	indicator_menu_item_visibility_changed_cb (self, _sender);
}


static void _indicator_menu_item_visibility_changed_cb_gtk_widget_hide (GtkWidget* _sender, gpointer self) {
	indicator_menu_item_visibility_changed_cb (self, _sender);
}


IndicatorMenuItem* indicator_menu_item_construct (GType object_type, IndicatorObjectEntry* entry) {
	IndicatorMenuItem * self = NULL;
	IndicatorObjectEntry* _tmp0_;
	GtkBox* _tmp1_;
	GtkBox* _tmp2_;
	GtkBox* _tmp3_;
	IndicatorObjectEntry* _tmp4_;
	GtkLabel* _tmp5_;
	IndicatorObjectEntry* _tmp13_;
	GtkImage* _tmp14_;
	IndicatorObjectEntry* _tmp22_;
	const gchar* _tmp23_;
	IndicatorObjectEntry* _tmp27_;
	GtkMenu* _tmp28_;
	gboolean _tmp31_ = FALSE;
	g_return_val_if_fail (entry != NULL, NULL);
	self = (IndicatorMenuItem*) g_object_new (object_type, NULL);
	_tmp0_ = entry;
	self->entry = _tmp0_;
	_tmp1_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 3);
	g_object_ref_sink (_tmp1_);
	_g_object_unref0 (self->priv->hbox);
	self->priv->hbox = _tmp1_;
	_tmp2_ = self->priv->hbox;
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) _tmp2_);
	_tmp3_ = self->priv->hbox;
	gtk_widget_show ((GtkWidget*) _tmp3_);
	_tmp4_ = entry;
	_tmp5_ = _tmp4_->label;
	if (_tmp5_ != NULL) {
		IndicatorObjectEntry* _tmp6_;
		GtkLabel* _tmp7_;
		IndicatorObjectEntry* _tmp8_;
		GtkLabel* _tmp9_;
		GtkBox* _tmp10_;
		IndicatorObjectEntry* _tmp11_;
		GtkLabel* _tmp12_;
		_tmp6_ = entry;
		_tmp7_ = _tmp6_->label;
		g_signal_connect_object ((GtkWidget*) _tmp7_, "show", (GCallback) _indicator_menu_item_visibility_changed_cb_gtk_widget_show, self, 0);
		_tmp8_ = entry;
		_tmp9_ = _tmp8_->label;
		g_signal_connect_object ((GtkWidget*) _tmp9_, "hide", (GCallback) _indicator_menu_item_visibility_changed_cb_gtk_widget_hide, self, 0);
		_tmp10_ = self->priv->hbox;
		_tmp11_ = entry;
		_tmp12_ = _tmp11_->label;
		gtk_box_pack_start (_tmp10_, (GtkWidget*) _tmp12_, FALSE, FALSE, (guint) 0);
	}
	_tmp13_ = entry;
	_tmp14_ = _tmp13_->image;
	if (_tmp14_ != NULL) {
		IndicatorObjectEntry* _tmp15_;
		GtkImage* _tmp16_;
		IndicatorObjectEntry* _tmp17_;
		GtkImage* _tmp18_;
		GtkBox* _tmp19_;
		IndicatorObjectEntry* _tmp20_;
		GtkImage* _tmp21_;
		_tmp15_ = entry;
		_tmp16_ = _tmp15_->image;
		g_signal_connect_object ((GtkWidget*) _tmp16_, "show", (GCallback) _indicator_menu_item_visibility_changed_cb_gtk_widget_show, self, 0);
		_tmp17_ = entry;
		_tmp18_ = _tmp17_->image;
		g_signal_connect_object ((GtkWidget*) _tmp18_, "hide", (GCallback) _indicator_menu_item_visibility_changed_cb_gtk_widget_hide, self, 0);
		_tmp19_ = self->priv->hbox;
		_tmp20_ = entry;
		_tmp21_ = _tmp20_->image;
		gtk_box_pack_start (_tmp19_, (GtkWidget*) _tmp21_, FALSE, FALSE, (guint) 0);
	}
	_tmp22_ = entry;
	_tmp23_ = _tmp22_->accessible_desc;
	if (_tmp23_ != NULL) {
		AtkObject* _tmp24_ = NULL;
		IndicatorObjectEntry* _tmp25_;
		const gchar* _tmp26_;
		_tmp24_ = gtk_widget_get_accessible ((GtkWidget*) self);
		_tmp25_ = entry;
		_tmp26_ = _tmp25_->accessible_desc;
		atk_object_set_name (_tmp24_, _tmp26_);
	}
	_tmp27_ = entry;
	_tmp28_ = _tmp27_->menu;
	if (_tmp28_ != NULL) {
		IndicatorObjectEntry* _tmp29_;
		GtkMenu* _tmp30_;
		_tmp29_ = entry;
		_tmp30_ = _tmp29_->menu;
		gtk_menu_item_set_submenu ((GtkMenuItem*) self, G_TYPE_CHECK_INSTANCE_TYPE (_tmp30_, GTK_TYPE_WIDGET) ? ((GtkWidget*) _tmp30_) : NULL);
	}
	_tmp31_ = indicator_menu_item_has_visible_child (self);
	if (_tmp31_) {
		gtk_widget_show ((GtkWidget*) self);
	}
	return self;
}


IndicatorMenuItem* indicator_menu_item_new (IndicatorObjectEntry* entry) {
	return indicator_menu_item_construct (TYPE_INDICATOR_MENU_ITEM, entry);
}


gboolean indicator_menu_item_has_visible_child (IndicatorMenuItem* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	IndicatorObjectEntry* _tmp2_;
	GtkImage* _tmp3_;
	gboolean _tmp7_;
	gboolean _tmp15_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp2_ = self->entry;
	_tmp3_ = _tmp2_->image;
	if (_tmp3_ != NULL) {
		IndicatorObjectEntry* _tmp4_;
		GtkImage* _tmp5_;
		gboolean _tmp6_ = FALSE;
		_tmp4_ = self->entry;
		_tmp5_ = _tmp4_->image;
		_tmp6_ = gtk_widget_get_visible ((GtkWidget*) _tmp5_);
		_tmp1_ = _tmp6_;
	} else {
		_tmp1_ = FALSE;
	}
	_tmp7_ = _tmp1_;
	if (_tmp7_) {
		_tmp0_ = TRUE;
	} else {
		gboolean _tmp8_ = FALSE;
		IndicatorObjectEntry* _tmp9_;
		GtkLabel* _tmp10_;
		gboolean _tmp14_;
		_tmp9_ = self->entry;
		_tmp10_ = _tmp9_->label;
		if (_tmp10_ != NULL) {
			IndicatorObjectEntry* _tmp11_;
			GtkLabel* _tmp12_;
			gboolean _tmp13_ = FALSE;
			_tmp11_ = self->entry;
			_tmp12_ = _tmp11_->label;
			_tmp13_ = gtk_widget_get_visible ((GtkWidget*) _tmp12_);
			_tmp8_ = _tmp13_;
		} else {
			_tmp8_ = FALSE;
		}
		_tmp14_ = _tmp8_;
		_tmp0_ = _tmp14_;
	}
	_tmp15_ = _tmp0_;
	result = _tmp15_;
	return result;
}


void indicator_menu_item_visibility_changed_cb (IndicatorMenuItem* self, GtkWidget* widget) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (widget != NULL);
	_tmp0_ = indicator_menu_item_has_visible_child (self);
	gtk_widget_set_visible ((GtkWidget*) self, _tmp0_);
}


static void indicator_menu_item_class_init (IndicatorMenuItemClass * klass) {
	indicator_menu_item_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (IndicatorMenuItemPrivate));
	G_OBJECT_CLASS (klass)->finalize = indicator_menu_item_finalize;
}


static void indicator_menu_item_instance_init (IndicatorMenuItem * self) {
	self->priv = INDICATOR_MENU_ITEM_GET_PRIVATE (self);
}


static void indicator_menu_item_finalize (GObject* obj) {
	IndicatorMenuItem * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_INDICATOR_MENU_ITEM, IndicatorMenuItem);
	_g_object_unref0 (self->priv->hbox);
	G_OBJECT_CLASS (indicator_menu_item_parent_class)->finalize (obj);
}


GType indicator_menu_item_get_type (void) {
	static volatile gsize indicator_menu_item_type_id__volatile = 0;
	if (g_once_init_enter (&indicator_menu_item_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (IndicatorMenuItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) indicator_menu_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (IndicatorMenuItem), 0, (GInstanceInitFunc) indicator_menu_item_instance_init, NULL };
		GType indicator_menu_item_type_id;
		indicator_menu_item_type_id = g_type_register_static (GTK_TYPE_MENU_ITEM, "IndicatorMenuItem", &g_define_type_info, 0);
		g_once_init_leave (&indicator_menu_item_type_id__volatile, indicator_menu_item_type_id);
	}
	return indicator_menu_item_type_id__volatile;
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


MenuBar* menu_bar_construct (GType object_type, Background* bg, GtkAccelGroup* ag) {
	MenuBar * self = NULL;
	Background* _tmp0_;
	GtkAccelGroup* _tmp1_;
	g_return_val_if_fail (bg != NULL, NULL);
	g_return_val_if_fail (ag != NULL, NULL);
	_tmp0_ = bg;
	_tmp1_ = ag;
	self = (MenuBar*) g_object_new (object_type, "background", _tmp0_, "accel-group", _tmp1_, NULL);
	return self;
}


MenuBar* menu_bar_new (Background* bg, GtkAccelGroup* ag) {
	return menu_bar_construct (TYPE_MENU_BAR, bg, ag);
}


static gboolean menu_bar_real_draw (GtkWidget* base, cairo_t* c) {
	MenuBar * self;
	gboolean result = FALSE;
	Background* _tmp0_;
	cairo_t* _tmp11_;
	cairo_t* _tmp12_;
	GList* _tmp13_ = NULL;
	self = (MenuBar*) base;
	g_return_val_if_fail (c != NULL, FALSE);
	_tmp0_ = self->priv->_background;
	if (_tmp0_ != NULL) {
		gint x = 0;
		gint y = 0;
		Background* _tmp1_;
		gint _tmp2_ = 0;
		gint _tmp3_ = 0;
		cairo_t* _tmp4_;
		cairo_t* _tmp5_;
		gint _tmp6_;
		gint _tmp7_;
		Background* _tmp8_;
		cairo_t* _tmp9_;
		cairo_t* _tmp10_;
		_tmp1_ = self->priv->_background;
		gtk_widget_translate_coordinates ((GtkWidget*) _tmp1_, (GtkWidget*) self, 0, 0, &_tmp2_, &_tmp3_);
		x = _tmp2_;
		y = _tmp3_;
		_tmp4_ = c;
		cairo_save (_tmp4_);
		_tmp5_ = c;
		_tmp6_ = x;
		_tmp7_ = y;
		cairo_translate (_tmp5_, (gdouble) _tmp6_, (gdouble) _tmp7_);
		_tmp8_ = self->priv->_background;
		_tmp9_ = c;
		background_draw_full (_tmp8_, _tmp9_, BACKGROUND_DRAW_FLAGS_NONE);
		_tmp10_ = c;
		cairo_restore (_tmp10_);
	}
	_tmp11_ = c;
	cairo_set_source_rgb (_tmp11_, 0.1, 0.1, 0.1);
	_tmp12_ = c;
	cairo_paint_with_alpha (_tmp12_, 0.4);
	_tmp13_ = gtk_container_get_children ((GtkContainer*) self);
	{
		GList* child_collection = NULL;
		GList* child_it = NULL;
		child_collection = _tmp13_;
		for (child_it = child_collection; child_it != NULL; child_it = child_it->next) {
			GtkWidget* child = NULL;
			child = (GtkWidget*) child_it->data;
			{
				GtkWidget* _tmp14_;
				cairo_t* _tmp15_;
				_tmp14_ = child;
				_tmp15_ = c;
				gtk_container_propagate_draw ((GtkContainer*) self, _tmp14_, _tmp15_);
			}
		}
		_g_list_free0 (child_collection);
	}
	result = FALSE;
	return result;
}


void menu_bar_set_keyboard_state (MenuBar* self) {
	GtkCheckMenuItem* _tmp0_;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->onscreen_keyboard_item;
	_tmp1_ = ug_settings_get_boolean (UG_SETTINGS_KEY_ONSCREEN_KEYBOARD);
	gtk_check_menu_item_set_active (_tmp0_, _tmp1_);
}


static void menu_bar_close_pid (MenuBar* self, GPid* pid) {
	GPid _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = *pid;
	if (_tmp0_ != ((GPid) 0)) {
		GPid _tmp1_;
		gint status = 0;
		GPid _tmp2_;
		gint _tmp3_ = 0;
		_tmp1_ = *pid;
		kill ((pid_t) _tmp1_, SIGTERM);
		_tmp2_ = *pid;
		waitpid ((pid_t) _tmp2_, &_tmp3_, 0);
		status = _tmp3_;
		*pid = (GPid) 0;
	}
}


void menu_bar_cleanup (MenuBar* self) {
	g_return_if_fail (self != NULL);
	menu_bar_close_pid (self, &self->priv->keyboard_pid);
	menu_bar_close_pid (self, &self->priv->reader_pid);
}


static void menu_bar_real_get_preferred_height (GtkWidget* base, gint* min, gint* nat) {
	MenuBar * self;
	gint _vala_min = 0;
	gint _vala_nat = 0;
	self = (MenuBar*) base;
	_vala_min = MENU_BAR_HEIGHT;
	_vala_nat = MENU_BAR_HEIGHT;
	if (min) {
		*min = _vala_min;
	}
	if (nat) {
		*nat = _vala_nat;
	}
}


static void menu_bar_greeter_set_env (MenuBar* self, const gchar* key, const gchar* val) {
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (key != NULL);
	g_return_if_fail (val != NULL);
	_tmp0_ = key;
	_tmp1_ = val;
	g_setenv (_tmp0_, _tmp1_, TRUE);
	{
		GDBusProxy* _tmp2_;
		GDBusProxy* proxy;
		const GVariantType* _tmp3_;
		GVariantBuilder* _tmp4_;
		GVariantBuilder* builder;
		GVariantBuilder* _tmp5_;
		const gchar* _tmp6_;
		const gchar* _tmp7_;
		GDBusProxy* _tmp8_;
		GVariantBuilder* _tmp9_;
		GVariant* _tmp10_;
		GVariant* _tmp11_;
		GVariant* _tmp12_ = NULL;
		GVariant* _tmp13_;
		_tmp2_ = g_dbus_proxy_new_for_bus_sync (G_BUS_TYPE_SESSION, G_DBUS_PROXY_FLAGS_NONE, NULL, "org.freedesktop.DBus", "/org/freedesktop/DBus", "org.freedesktop.DBus", NULL, &_inner_error_);
		proxy = _tmp2_;
		if (_inner_error_ != NULL) {
			goto __catch12_g_error;
		}
		_tmp3_ = G_VARIANT_TYPE_ARRAY;
		_tmp4_ = g_variant_builder_new (_tmp3_);
		builder = _tmp4_;
		_tmp5_ = builder;
		_tmp6_ = key;
		_tmp7_ = val;
		g_variant_builder_add (_tmp5_, "{ss}", _tmp6_, _tmp7_, NULL);
		_tmp8_ = proxy;
		_tmp9_ = builder;
		_tmp10_ = g_variant_new ("(a{ss})", _tmp9_, NULL);
		g_variant_ref_sink (_tmp10_);
		_tmp11_ = _tmp10_;
		_tmp12_ = g_dbus_proxy_call_sync (_tmp8_, "UpdateActivationEnvironment", _tmp11_, G_DBUS_CALL_FLAGS_NONE, -1, NULL, &_inner_error_);
		_tmp13_ = _tmp12_;
		_g_variant_unref0 (_tmp13_);
		_g_variant_unref0 (_tmp11_);
		if (_inner_error_ != NULL) {
			_g_variant_builder_unref0 (builder);
			_g_object_unref0 (proxy);
			goto __catch12_g_error;
		}
		_g_variant_builder_unref0 (builder);
		_g_object_unref0 (proxy);
	}
	goto __finally12;
	__catch12_g_error:
	{
		GError* e = NULL;
		GError* _tmp14_;
		const gchar* _tmp15_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp14_ = e;
		_tmp15_ = _tmp14_->message;
		g_warning ("menubar.vala:201: Could not get set environment for indicators: %s", _tmp15_);
		_g_error_free0 (e);
		return;
	}
	__finally12:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void _menu_bar_keyboard_toggled_cb_gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self) {
	menu_bar_keyboard_toggled_cb (self, _sender);
}


static void _menu_bar_high_contrast_toggled_cb_gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self) {
	menu_bar_high_contrast_toggled_cb (self, _sender);
}


static void _menu_bar_screen_reader_toggled_cb_gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self) {
	menu_bar_screen_reader_toggled_cb (self, _sender);
}


static GtkWidget* menu_bar_make_a11y_indicator (MenuBar* self) {
	GtkWidget* result = NULL;
	GtkMenuItem* _tmp0_;
	GtkMenuItem* a11y_item;
	GtkBox* _tmp1_;
	GtkBox* hbox;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	GtkImage* _tmp4_;
	GtkImage* _tmp5_;
	GtkImage* image;
	GtkMenu* _tmp6_;
	GtkWidget* _tmp7_;
	GtkWidget* _tmp8_;
	const gchar* _tmp9_ = NULL;
	GtkCheckMenuItem* _tmp10_;
	GtkCheckMenuItem* _tmp11_;
	GtkCheckMenuItem* _tmp12_;
	GtkMenu* _tmp13_;
	GtkMenu* _tmp14_;
	GtkMenu* submenu;
	GtkCheckMenuItem* _tmp15_;
	const gchar* _tmp16_ = NULL;
	GtkCheckMenuItem* _tmp17_;
	GtkCheckMenuItem* _tmp18_;
	GtkCheckMenuItem* _tmp19_;
	GtkAccelGroup* _tmp20_;
	GtkCheckMenuItem* _tmp21_;
	GtkCheckMenuItem* _tmp22_;
	GtkCheckMenuItem* _tmp23_;
	gboolean _tmp24_ = FALSE;
	const gchar* _tmp25_ = NULL;
	GtkCheckMenuItem* _tmp26_;
	GtkCheckMenuItem* item;
	GtkAccelGroup* _tmp27_;
	gboolean _tmp28_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = (GtkMenuItem*) gtk_menu_item_new ();
	g_object_ref_sink (_tmp0_);
	a11y_item = _tmp0_;
	_tmp1_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 3);
	g_object_ref_sink (_tmp1_);
	hbox = _tmp1_;
	gtk_widget_show ((GtkWidget*) hbox);
	gtk_container_add ((GtkContainer*) a11y_item, (GtkWidget*) hbox);
	_tmp2_ = g_build_filename (PKGDATADIR, "a11y.svg", NULL);
	_tmp3_ = _tmp2_;
	_tmp4_ = (GtkImage*) gtk_image_new_from_file (_tmp3_);
	g_object_ref_sink (_tmp4_);
	_tmp5_ = _tmp4_;
	_g_free0 (_tmp3_);
	image = _tmp5_;
	gtk_widget_show ((GtkWidget*) image);
	gtk_container_add ((GtkContainer*) hbox, (GtkWidget*) image);
	gtk_widget_show ((GtkWidget*) a11y_item);
	_tmp6_ = (GtkMenu*) gtk_menu_new ();
	g_object_ref_sink (_tmp6_);
	_tmp7_ = G_TYPE_CHECK_INSTANCE_TYPE (_tmp6_, GTK_TYPE_WIDGET) ? ((GtkWidget*) _tmp6_) : NULL;
	if (_tmp7_ == NULL) {
		_g_object_unref0 (_tmp6_);
	}
	_tmp8_ = _tmp7_;
	gtk_menu_item_set_submenu (a11y_item, _tmp8_);
	_g_object_unref0 (_tmp8_);
	_tmp9_ = _ ("Onscreen keyboard");
	_tmp10_ = (GtkCheckMenuItem*) gtk_check_menu_item_new_with_label (_tmp9_);
	g_object_ref_sink (_tmp10_);
	_g_object_unref0 (self->priv->onscreen_keyboard_item);
	self->priv->onscreen_keyboard_item = _tmp10_;
	_tmp11_ = self->priv->onscreen_keyboard_item;
	g_signal_connect_object (_tmp11_, "toggled", (GCallback) _menu_bar_keyboard_toggled_cb_gtk_check_menu_item_toggled, self, 0);
	_tmp12_ = self->priv->onscreen_keyboard_item;
	gtk_widget_show ((GtkWidget*) _tmp12_);
	_tmp13_ = gtk_menu_item_get_submenu (a11y_item);
	_tmp14_ = _tmp13_;
	submenu = _tmp14_;
	_tmp15_ = self->priv->onscreen_keyboard_item;
	gtk_menu_shell_append ((GtkMenuShell*) submenu, (GtkWidget*) ((GtkMenuItem*) _tmp15_));
	_tmp16_ = _ ("High Contrast");
	_tmp17_ = (GtkCheckMenuItem*) gtk_check_menu_item_new_with_label (_tmp16_);
	g_object_ref_sink (_tmp17_);
	_g_object_unref0 (self->priv->high_contrast_item);
	self->priv->high_contrast_item = _tmp17_;
	_tmp18_ = self->priv->high_contrast_item;
	g_signal_connect_object (_tmp18_, "toggled", (GCallback) _menu_bar_high_contrast_toggled_cb_gtk_check_menu_item_toggled, self, 0);
	_tmp19_ = self->priv->high_contrast_item;
	_tmp20_ = self->priv->_accel_group;
	gtk_widget_add_accelerator ((GtkWidget*) _tmp19_, "activate", _tmp20_, (guint) GDK_KEY_h, GDK_CONTROL_MASK, GTK_ACCEL_VISIBLE);
	_tmp21_ = self->priv->high_contrast_item;
	gtk_widget_show ((GtkWidget*) _tmp21_);
	_tmp22_ = self->priv->high_contrast_item;
	gtk_menu_shell_append ((GtkMenuShell*) submenu, (GtkWidget*) ((GtkMenuItem*) _tmp22_));
	_tmp23_ = self->priv->high_contrast_item;
	_tmp24_ = ug_settings_get_boolean (UG_SETTINGS_KEY_HIGH_CONTRAST);
	gtk_check_menu_item_set_active (_tmp23_, _tmp24_);
	_tmp25_ = _ ("Screen Reader");
	_tmp26_ = (GtkCheckMenuItem*) gtk_check_menu_item_new_with_label (_tmp25_);
	g_object_ref_sink (_tmp26_);
	item = _tmp26_;
	g_signal_connect_object (item, "toggled", (GCallback) _menu_bar_screen_reader_toggled_cb_gtk_check_menu_item_toggled, self, 0);
	_tmp27_ = self->priv->_accel_group;
	gtk_widget_add_accelerator ((GtkWidget*) item, "activate", _tmp27_, (guint) GDK_KEY_s, GDK_CONTROL_MASK, GTK_ACCEL_VISIBLE);
	gtk_widget_show ((GtkWidget*) item);
	gtk_menu_shell_append ((GtkMenuShell*) submenu, (GtkWidget*) ((GtkMenuItem*) item));
	_tmp28_ = ug_settings_get_boolean (UG_SETTINGS_KEY_SCREEN_READER);
	gtk_check_menu_item_set_active (item, _tmp28_);
	result = (GtkWidget*) a11y_item;
	_g_object_unref0 (item);
	_g_object_unref0 (image);
	_g_object_unref0 (hbox);
	return result;
}


static gint string_index_of_char (const gchar* self, gunichar c, gint start_index) {
	gint result = 0;
	gint _tmp0_;
	gunichar _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* _result_;
	gchar* _tmp3_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = c;
	_tmp2_ = g_utf8_strchr (((gchar*) self) + _tmp0_, (gssize) (-1), _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static IndicatorObject* menu_bar_load_indicator_file (MenuBar* self, const gchar* indicator_name) {
	IndicatorObject* result = NULL;
	gchar* _tmp0_;
	gchar* dir;
	gchar* path = NULL;
	IndicatorObject* io = NULL;
	const gchar* _tmp1_;
	gint _tmp2_ = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (indicator_name != NULL, NULL);
	_tmp0_ = g_strdup (INDICATOR_FILE_DIR);
	dir = _tmp0_;
	_tmp1_ = indicator_name;
	_tmp2_ = string_index_of_char (_tmp1_, (gunichar) '.', 0);
	if (_tmp2_ < 0) {
		const gchar* _tmp3_;
		const gchar* _tmp4_ = NULL;
		const gchar* _tmp5_;
		const gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		_tmp3_ = dir;
		_tmp4_ = string_to_string (_tmp3_);
		_tmp5_ = indicator_name;
		_tmp6_ = string_to_string (_tmp5_);
		_tmp7_ = g_strconcat (_tmp4_, "/com.canonical.indicator.", _tmp6_, NULL);
		_g_free0 (path);
		path = _tmp7_;
	} else {
		const gchar* _tmp8_;
		const gchar* _tmp9_ = NULL;
		const gchar* _tmp10_;
		const gchar* _tmp11_ = NULL;
		gchar* _tmp12_ = NULL;
		_tmp8_ = dir;
		_tmp9_ = string_to_string (_tmp8_);
		_tmp10_ = indicator_name;
		_tmp11_ = string_to_string (_tmp10_);
		_tmp12_ = g_strconcat (_tmp9_, "/", _tmp11_, NULL);
		_g_free0 (path);
		path = _tmp12_;
	}
	{
		const gchar* _tmp13_;
		IndicatorNg* _tmp14_;
		IndicatorNg* _tmp15_;
		_tmp13_ = path;
		_tmp14_ = indicator_ng_new_for_profile (_tmp13_, "desktop_greeter", &_inner_error_);
		_tmp15_ = _tmp14_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_FILE_ERROR) {
				goto __catch13_g_file_error;
			}
			goto __catch13_g_error;
		}
		_g_object_unref0 (io);
		io = (IndicatorObject*) _tmp15_;
	}
	goto __finally13;
	__catch13_g_file_error:
	{
		GError* _error_ = NULL;
		_error_ = _inner_error_;
		_inner_error_ = NULL;
		result = NULL;
		_g_error_free0 (_error_);
		_g_object_unref0 (io);
		_g_free0 (path);
		_g_free0 (dir);
		return result;
	}
	goto __finally13;
	__catch13_g_error:
	{
		GError* _error_ = NULL;
		const gchar* _tmp16_;
		GError* _tmp17_;
		const gchar* _tmp18_;
		_error_ = _inner_error_;
		_inner_error_ = NULL;
		_tmp16_ = indicator_name;
		_tmp17_ = _error_;
		_tmp18_ = _tmp17_->message;
		g_warning ("menubar.vala:260: unable to load %s: %s", _tmp16_, _tmp18_);
		result = NULL;
		_g_error_free0 (_error_);
		_g_object_unref0 (io);
		_g_free0 (path);
		_g_free0 (dir);
		return result;
	}
	__finally13:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (io);
		_g_free0 (path);
		_g_free0 (dir);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = io;
	_g_free0 (path);
	_g_free0 (dir);
	return result;
}


static IndicatorObject* menu_bar_load_indicator_library (MenuBar* self, const gchar* indicator_name) {
	IndicatorObject* result = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	const gchar* _tmp6_;
	gchar* _tmp7_;
	gchar** _tmp8_ = NULL;
	gchar** _tmp9_;
	gint _tmp9__length1;
	gchar** names_to_try;
	gint names_to_try_length1;
	gint _names_to_try_size_;
	gchar** _tmp10_;
	gint _tmp10__length1;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (indicator_name != NULL, NULL);
	_tmp0_ = indicator_name;
	_tmp1_ = g_strconcat ("lib", _tmp0_, NULL);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strconcat (_tmp2_, ".so", NULL);
	_tmp4_ = indicator_name;
	_tmp5_ = g_strconcat (_tmp4_, ".so", NULL);
	_tmp6_ = indicator_name;
	_tmp7_ = g_strdup (_tmp6_);
	_tmp8_ = g_new0 (gchar*, 3 + 1);
	_tmp8_[0] = _tmp3_;
	_tmp8_[1] = _tmp5_;
	_tmp8_[2] = _tmp7_;
	_tmp9_ = _tmp8_;
	_tmp9__length1 = 3;
	_g_free0 (_tmp2_);
	names_to_try = _tmp9_;
	names_to_try_length1 = _tmp9__length1;
	_names_to_try_size_ = names_to_try_length1;
	_tmp10_ = names_to_try;
	_tmp10__length1 = names_to_try_length1;
	{
		gchar** filename_collection = NULL;
		gint filename_collection_length1 = 0;
		gint _filename_collection_size_ = 0;
		gint filename_it = 0;
		filename_collection = _tmp10_;
		filename_collection_length1 = _tmp10__length1;
		for (filename_it = 0; filename_it < _tmp10__length1; filename_it = filename_it + 1) {
			gchar* _tmp11_;
			gchar* filename = NULL;
			_tmp11_ = g_strdup (filename_collection[filename_it]);
			filename = _tmp11_;
			{
				const gchar* _tmp12_;
				gchar* _tmp13_ = NULL;
				gchar* full_path;
				const gchar* _tmp14_;
				IndicatorObject* _tmp15_;
				IndicatorObject* io;
				IndicatorObject* _tmp16_;
				_tmp12_ = filename;
				_tmp13_ = g_build_filename (INDICATORDIR, _tmp12_, NULL);
				full_path = _tmp13_;
				_tmp14_ = full_path;
				_tmp15_ = indicator_object_new_from_file (_tmp14_);
				io = _tmp15_;
				_tmp16_ = io;
				if (_tmp16_ != NULL) {
					result = io;
					_g_free0 (full_path);
					_g_free0 (filename);
					names_to_try = (_vala_array_free (names_to_try, names_to_try_length1, (GDestroyNotify) g_free), NULL);
					return result;
				}
				_g_object_unref0 (io);
				_g_free0 (full_path);
				_g_free0 (filename);
			}
		}
	}
	result = NULL;
	names_to_try = (_vala_array_free (names_to_try, names_to_try_length1, (GDestroyNotify) g_free), NULL);
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void _menu_bar_indicator_added_cb_indicator_object_entry_added (IndicatorObject* _sender, IndicatorObjectEntry* entry, gpointer self) {
	menu_bar_indicator_added_cb (self, _sender, entry);
}


static void _menu_bar_indicator_removed_cb_indicator_object_entry_removed (IndicatorObject* _sender, IndicatorObjectEntry* entry, gpointer self) {
	menu_bar_indicator_removed_cb (self, _sender, entry);
}


static void menu_bar_load_indicator (MenuBar* self, const gchar* indicator_name) {
	const gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (indicator_name != NULL);
	_tmp0_ = indicator_name;
	if (g_strcmp0 (_tmp0_, "ug-accessibility") == 0) {
		GtkWidget* _tmp1_ = NULL;
		GtkWidget* a11y_item;
		GtkWidget* _tmp2_;
		GList* _tmp3_ = NULL;
		GList* _tmp4_;
		guint _tmp5_ = 0U;
		_tmp1_ = menu_bar_make_a11y_indicator (self);
		a11y_item = _tmp1_;
		_tmp2_ = a11y_item;
		_tmp3_ = gtk_container_get_children ((GtkContainer*) self);
		_tmp4_ = _tmp3_;
		_tmp5_ = g_list_length (_tmp4_);
		gtk_menu_shell_insert ((GtkMenuShell*) self, _tmp2_, ((gint) _tmp5_) - 1);
		_g_list_free0 (_tmp4_);
		_g_object_unref0 (a11y_item);
	} else {
		const gchar* _tmp6_;
		IndicatorObject* _tmp7_ = NULL;
		IndicatorObject* io;
		IndicatorObject* _tmp8_;
		IndicatorObject* _tmp11_;
		_tmp6_ = indicator_name;
		_tmp7_ = menu_bar_load_indicator_file (self, _tmp6_);
		io = _tmp7_;
		_tmp8_ = io;
		if (_tmp8_ == NULL) {
			const gchar* _tmp9_;
			IndicatorObject* _tmp10_ = NULL;
			_tmp9_ = indicator_name;
			_tmp10_ = menu_bar_load_indicator_library (self, _tmp9_);
			_g_object_unref0 (io);
			io = _tmp10_;
		}
		_tmp11_ = io;
		if (_tmp11_ != NULL) {
			IndicatorObject* _tmp12_;
			IndicatorObject* _tmp13_;
			IndicatorObject* _tmp14_;
			IndicatorObject* _tmp15_;
			IndicatorObject* _tmp16_;
			GList* _tmp17_ = NULL;
			_tmp12_ = io;
			_tmp13_ = _g_object_ref0 (_tmp12_);
			self->priv->indicator_objects = g_list_append (self->priv->indicator_objects, _tmp13_);
			_tmp14_ = io;
			g_signal_connect_object (_tmp14_, "entry-added", (GCallback) _menu_bar_indicator_added_cb_indicator_object_entry_added, self, 0);
			_tmp15_ = io;
			g_signal_connect_object (_tmp15_, "entry-removed", (GCallback) _menu_bar_indicator_removed_cb_indicator_object_entry_removed, self, 0);
			_tmp16_ = io;
			_tmp17_ = indicator_object_get_entries (_tmp16_);
			{
				GList* entry_collection = NULL;
				GList* entry_it = NULL;
				entry_collection = _tmp17_;
				for (entry_it = entry_collection; entry_it != NULL; entry_it = entry_it->next) {
					IndicatorObjectEntry* entry = NULL;
					entry = (IndicatorObjectEntry*) entry_it->data;
					{
						IndicatorObject* _tmp18_;
						IndicatorObjectEntry* _tmp19_;
						_tmp18_ = io;
						_tmp19_ = entry;
						menu_bar_indicator_added_cb (self, _tmp18_, _tmp19_);
					}
				}
				_g_list_free0 (entry_collection);
			}
		}
		_g_object_unref0 (io);
	}
}


static gint __lambda34_ (IndicatorObject* a, IndicatorObject* b) {
	gint result = 0;
	IndicatorObject* _tmp0_;
	gint _tmp1_ = 0;
	gint pos_a;
	IndicatorObject* _tmp2_;
	gint _tmp3_ = 0;
	gint pos_b;
	gint _tmp4_;
	gint _tmp5_;
	gint _tmp6_;
	gint _tmp7_;
	g_return_val_if_fail (a != NULL, 0);
	g_return_val_if_fail (b != NULL, 0);
	_tmp0_ = a;
	_tmp1_ = indicator_object_get_position (_tmp0_);
	pos_a = _tmp1_;
	_tmp2_ = b;
	_tmp3_ = indicator_object_get_position (_tmp2_);
	pos_b = _tmp3_;
	_tmp4_ = pos_a;
	if (_tmp4_ < 0) {
		pos_a = 1000;
	}
	_tmp5_ = pos_b;
	if (_tmp5_ < 0) {
		pos_b = 1000;
	}
	_tmp6_ = pos_a;
	_tmp7_ = pos_b;
	result = _tmp6_ - _tmp7_;
	return result;
}


static gint ___lambda34__gcompare_func (gconstpointer a, gconstpointer b) {
	gint result;
	result = __lambda34_ (a, b);
	return result;
}


static void menu_bar_setup_indicators (MenuBar* self) {
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	gchar** _tmp7_ = NULL;
	gchar** indicator_list;
	gint indicator_list_length1;
	gint _indicator_list_size_;
	gboolean update_indicator_list;
	gboolean _tmp20_;
	gchar** _tmp22_;
	gint _tmp22__length1;
	const gchar* _tmp25_ = NULL;
	const gchar* _tmp26_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	menu_bar_greeter_set_env (self, "INDICATOR_GREETER_MODE", "1");
	menu_bar_greeter_set_env (self, "GIO_USE_VFS", "local");
	menu_bar_greeter_set_env (self, "GVFS_DISABLE_FUSE", "1");
	menu_bar_greeter_set_env (self, "RUNNING_UNDER_GDM", "1");
	{
		GDBusConnection* _tmp0_ = NULL;
		GDBusConnection* conn;
		const gchar* _tmp1_ = NULL;
		_tmp0_ = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, &_inner_error_);
		conn = _tmp0_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch14_g_io_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp1_ = g_dbus_connection_get_unique_name (conn);
		menu_bar_greeter_set_env (self, "UNITY_GREETER_DBUS_NAME", _tmp1_);
		_g_object_unref0 (conn);
	}
	goto __finally14;
	__catch14_g_io_error:
	{
		GError* e = NULL;
		GError* _tmp2_;
		const gchar* _tmp3_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp2_ = e;
		_tmp3_ = _tmp2_->message;
		g_debug ("menubar.vala:329: Could not set DBUS_NAME: %s", _tmp3_);
		_g_error_free0 (e);
	}
	__finally14:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp4_ = g_getenv ("LANG");
	_tmp5_ = g_getenv ("LANGUAGE");
	g_debug ("menubar.vala:332: LANG=%s LANGUAGE=%s", _tmp4_, _tmp5_);
	_tmp7_ = ug_settings_get_strv (UG_SETTINGS_KEY_INDICATORS, &_tmp6_);
	indicator_list = _tmp7_;
	indicator_list_length1 = _tmp6_;
	_indicator_list_size_ = indicator_list_length1;
	update_indicator_list = FALSE;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp8_;
			_tmp8_ = TRUE;
			while (TRUE) {
				gboolean _tmp9_;
				gint _tmp11_;
				gchar** _tmp12_;
				gint _tmp12__length1;
				gchar** _tmp13_;
				gint _tmp13__length1;
				gint _tmp14_;
				const gchar* _tmp15_;
				_tmp9_ = _tmp8_;
				if (!_tmp9_) {
					gint _tmp10_;
					_tmp10_ = i;
					i = _tmp10_ + 1;
				}
				_tmp8_ = FALSE;
				_tmp11_ = i;
				_tmp12_ = indicator_list;
				_tmp12__length1 = indicator_list_length1;
				if (!(_tmp11_ < _tmp12__length1)) {
					break;
				}
				_tmp13_ = indicator_list;
				_tmp13__length1 = indicator_list_length1;
				_tmp14_ = i;
				_tmp15_ = _tmp13_[_tmp14_];
				if (g_strcmp0 (_tmp15_, "ug-keyboard") == 0) {
					gchar** _tmp16_;
					gint _tmp16__length1;
					gint _tmp17_;
					gchar* _tmp18_;
					gchar* _tmp19_;
					_tmp16_ = indicator_list;
					_tmp16__length1 = indicator_list_length1;
					_tmp17_ = i;
					_tmp18_ = g_strdup ("com.canonical.indicator.keyboard");
					_g_free0 (_tmp16_[_tmp17_]);
					_tmp16_[_tmp17_] = _tmp18_;
					_tmp19_ = _tmp16_[_tmp17_];
					update_indicator_list = TRUE;
				}
			}
		}
	}
	_tmp20_ = update_indicator_list;
	if (_tmp20_) {
		gchar** _tmp21_;
		gint _tmp21__length1;
		_tmp21_ = indicator_list;
		_tmp21__length1 = indicator_list_length1;
		ug_settings_set_strv (UG_SETTINGS_KEY_INDICATORS, _tmp21_, _tmp21__length1);
	}
	_tmp22_ = indicator_list;
	_tmp22__length1 = indicator_list_length1;
	{
		gchar** indicator_collection = NULL;
		gint indicator_collection_length1 = 0;
		gint _indicator_collection_size_ = 0;
		gint indicator_it = 0;
		indicator_collection = _tmp22_;
		indicator_collection_length1 = _tmp22__length1;
		for (indicator_it = 0; indicator_it < _tmp22__length1; indicator_it = indicator_it + 1) {
			gchar* _tmp23_;
			gchar* indicator = NULL;
			_tmp23_ = g_strdup (indicator_collection[indicator_it]);
			indicator = _tmp23_;
			{
				const gchar* _tmp24_;
				_tmp24_ = indicator;
				menu_bar_load_indicator (self, _tmp24_);
				_g_free0 (indicator);
			}
		}
	}
	self->priv->indicator_objects = g_list_sort (self->priv->indicator_objects, ___lambda34__gcompare_func);
	_tmp25_ = g_getenv ("LANG");
	_tmp26_ = g_getenv ("LANGUAGE");
	g_debug ("menubar.vala:364: LANG=%s LANGUAGE=%s", _tmp25_, _tmp26_);
	indicator_list = (_vala_array_free (indicator_list, indicator_list_length1, (GDestroyNotify) g_free), NULL);
}


static void menu_bar_keyboard_toggled_cb (MenuBar* self, GtkCheckMenuItem* item) {
	GtkCheckMenuItem* _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	GtkWindow* _tmp3_;
	GtkWindow* _tmp47_;
	GtkCheckMenuItem* _tmp48_;
	gboolean _tmp49_;
	gboolean _tmp50_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (item != NULL);
	_tmp0_ = item;
	_tmp1_ = gtk_check_menu_item_get_active (_tmp0_);
	_tmp2_ = _tmp1_;
	ug_settings_set_boolean (UG_SETTINGS_KEY_ONSCREEN_KEYBOARD, _tmp2_);
	_tmp3_ = self->priv->_keyboard_window;
	if (_tmp3_ == NULL) {
		gint id;
		GtkSocket* _tmp19_;
		GtkSocket* keyboard_socket;
		GtkSocket* _tmp20_;
		GtkWindow* _tmp21_;
		GtkWindow* _tmp22_;
		GtkWindow* _tmp23_;
		GtkWindow* _tmp24_;
		GtkWindow* _tmp25_;
		GtkSocket* _tmp26_;
		GtkSocket* _tmp27_;
		gint _tmp28_;
		GdkScreen* _tmp29_ = NULL;
		GdkScreen* _tmp30_;
		GdkScreen* screen;
		GdkScreen* _tmp31_;
		GdkWindow* _tmp32_ = NULL;
		gint _tmp33_ = 0;
		gint monitor;
		GdkRectangle geom = {0};
		GdkScreen* _tmp34_;
		gint _tmp35_;
		GdkRectangle _tmp36_ = {0};
		GtkWindow* _tmp37_;
		GdkRectangle _tmp38_;
		gint _tmp39_;
		GdkRectangle _tmp40_;
		gint _tmp41_;
		GdkRectangle _tmp42_;
		gint _tmp43_;
		GtkWindow* _tmp44_;
		GdkRectangle _tmp45_;
		gint _tmp46_;
		id = 0;
		{
			gchar** argv = NULL;
			gint argv_length1 = 0;
			gint _argv_size_ = 0;
			gint onboard_stdout_fd = 0;
			gchar** _tmp4_ = NULL;
			gint _tmp5_ = 0;
			gchar** _tmp6_;
			gint _tmp6__length1;
			GPid _tmp7_ = 0;
			gint _tmp8_ = 0;
			gint _tmp9_;
			FILE* _tmp10_ = NULL;
			FILE* f;
			gchar* _tmp11_ = NULL;
			gchar* stdout_text;
			gint stdout_text_length1;
			gint _stdout_text_size_;
			FILE* _tmp12_;
			gchar* _tmp13_;
			gint _tmp13__length1;
			const gchar* _tmp14_ = NULL;
			g_shell_parse_argv ("onboard --xid", &_tmp5_, &_tmp4_, &_inner_error_);
			argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
			argv = _tmp4_;
			argv_length1 = _tmp5_;
			_argv_size_ = argv_length1;
			if (_inner_error_ != NULL) {
				argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
				goto __catch15_g_error;
			}
			_tmp6_ = argv;
			_tmp6__length1 = argv_length1;
			g_spawn_async_with_pipes (NULL, _tmp6_, NULL, G_SPAWN_SEARCH_PATH, NULL, NULL, &_tmp7_, NULL, &_tmp8_, NULL, &_inner_error_);
			self->priv->keyboard_pid = _tmp7_;
			onboard_stdout_fd = _tmp8_;
			if (_inner_error_ != NULL) {
				argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
				goto __catch15_g_error;
			}
			_tmp9_ = onboard_stdout_fd;
			_tmp10_ = fdopen (_tmp9_, "r");
			f = _tmp10_;
			_tmp11_ = g_new0 (gchar, 1024);
			stdout_text = _tmp11_;
			stdout_text_length1 = 1024;
			_stdout_text_size_ = stdout_text_length1;
			_tmp12_ = f;
			_tmp13_ = stdout_text;
			_tmp13__length1 = stdout_text_length1;
			_tmp14_ = fgets (_tmp13_, _tmp13__length1, _tmp12_);
			if (_tmp14_ != NULL) {
				gchar* _tmp15_;
				gint _tmp15__length1;
				gint _tmp16_ = 0;
				_tmp15_ = stdout_text;
				_tmp15__length1 = stdout_text_length1;
				_tmp16_ = atoi ((const gchar*) _tmp15_);
				id = _tmp16_;
			}
			stdout_text = (g_free (stdout_text), NULL);
			_fclose0 (f);
			argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
		}
		goto __finally15;
		__catch15_g_error:
		{
			GError* e = NULL;
			GError* _tmp17_;
			const gchar* _tmp18_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp17_ = e;
			_tmp18_ = _tmp17_->message;
			g_warning ("menubar.vala:404: Error setting up keyboard: %s", _tmp18_);
			_g_error_free0 (e);
			return;
		}
		__finally15:
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp19_ = (GtkSocket*) gtk_socket_new ();
		g_object_ref_sink (_tmp19_);
		keyboard_socket = _tmp19_;
		_tmp20_ = keyboard_socket;
		gtk_widget_show ((GtkWidget*) _tmp20_);
		_tmp21_ = (GtkWindow*) gtk_window_new (GTK_WINDOW_TOPLEVEL);
		g_object_ref_sink (_tmp21_);
		_tmp22_ = _tmp21_;
		menu_bar_set_keyboard_window (self, _tmp22_);
		_g_object_unref0 (_tmp22_);
		_tmp23_ = self->priv->_keyboard_window;
		gtk_window_set_accept_focus (_tmp23_, FALSE);
		_tmp24_ = self->priv->_keyboard_window;
		gtk_window_set_focus_on_map (_tmp24_, FALSE);
		_tmp25_ = self->priv->_keyboard_window;
		_tmp26_ = keyboard_socket;
		gtk_container_add ((GtkContainer*) _tmp25_, (GtkWidget*) _tmp26_);
		_tmp27_ = keyboard_socket;
		_tmp28_ = id;
		gtk_socket_add_id (_tmp27_, _tmp28_);
		_tmp29_ = gtk_widget_get_screen ((GtkWidget*) self);
		_tmp30_ = _g_object_ref0 (_tmp29_);
		screen = _tmp30_;
		_tmp31_ = screen;
		_tmp32_ = gtk_widget_get_window ((GtkWidget*) self);
		_tmp33_ = gdk_screen_get_monitor_at_window (_tmp31_, _tmp32_);
		monitor = _tmp33_;
		_tmp34_ = screen;
		_tmp35_ = monitor;
		gdk_screen_get_monitor_geometry (_tmp34_, _tmp35_, &_tmp36_);
		geom = _tmp36_;
		_tmp37_ = self->priv->_keyboard_window;
		_tmp38_ = geom;
		_tmp39_ = _tmp38_.x;
		_tmp40_ = geom;
		_tmp41_ = _tmp40_.y;
		_tmp42_ = geom;
		_tmp43_ = _tmp42_.height;
		gtk_window_move (_tmp37_, _tmp39_, (_tmp41_ + _tmp43_) - 200);
		_tmp44_ = self->priv->_keyboard_window;
		_tmp45_ = geom;
		_tmp46_ = _tmp45_.width;
		gtk_window_resize (_tmp44_, _tmp46_, 200);
		_g_object_unref0 (screen);
		_g_object_unref0 (keyboard_socket);
	}
	_tmp47_ = self->priv->_keyboard_window;
	_tmp48_ = item;
	_tmp49_ = gtk_check_menu_item_get_active (_tmp48_);
	_tmp50_ = _tmp49_;
	gtk_widget_set_visible ((GtkWidget*) _tmp47_, _tmp50_);
}


static void menu_bar_high_contrast_toggled_cb (MenuBar* self, GtkCheckMenuItem* item) {
	GtkSettings* _tmp0_ = NULL;
	GtkSettings* _tmp1_;
	GtkSettings* settings;
	GtkCheckMenuItem* _tmp2_;
	gboolean _tmp3_;
	gboolean _tmp4_;
	GtkCheckMenuItem* _tmp8_;
	gboolean _tmp9_;
	gboolean _tmp10_;
	gboolean _tmp11_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (item != NULL);
	_tmp0_ = gtk_settings_get_default ();
	_tmp1_ = _g_object_ref0 (_tmp0_);
	settings = _tmp1_;
	_tmp2_ = item;
	_tmp3_ = gtk_check_menu_item_get_active (_tmp2_);
	_tmp4_ = _tmp3_;
	if (_tmp4_) {
		GtkSettings* _tmp5_;
		_tmp5_ = settings;
		g_object_set ((GObject*) _tmp5_, "gtk-theme-name", "HighContrastInverse", NULL);
	} else {
		GtkSettings* _tmp6_;
		const gchar* _tmp7_;
		_tmp6_ = settings;
		_tmp7_ = self->priv->default_theme_name;
		g_object_set ((GObject*) _tmp6_, "gtk-theme-name", _tmp7_, NULL);
	}
	_tmp8_ = item;
	_tmp9_ = gtk_check_menu_item_get_active (_tmp8_);
	_tmp10_ = _tmp9_;
	menu_bar_set_high_contrast (self, _tmp10_);
	_tmp11_ = self->priv->_high_contrast;
	ug_settings_set_boolean (UG_SETTINGS_KEY_HIGH_CONTRAST, _tmp11_);
	_g_object_unref0 (settings);
}


static gboolean ____lambda33_ (MenuBar* self) {
	gboolean result = FALSE;
	GtkWidget* _tmp0_ = NULL;
	GtkWidget* _tmp1_ = NULL;
	AtkObject* _tmp2_ = NULL;
	_tmp0_ = gtk_widget_get_toplevel ((GtkWidget*) self);
	_tmp1_ = gtk_window_get_focus (G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, GTK_TYPE_WINDOW) ? ((GtkWindow*) _tmp0_) : NULL);
	_tmp2_ = gtk_widget_get_accessible (_tmp1_);
	g_signal_emit_by_name (_tmp2_, "focus-event", TRUE, NULL);
	result = FALSE;
	return result;
}


static gboolean _____lambda33__gsource_func (gpointer self) {
	gboolean result;
	result = ____lambda33_ (self);
	return result;
}


static void menu_bar_screen_reader_toggled_cb (MenuBar* self, GtkCheckMenuItem* item) {
	GtkCheckMenuItem* _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	GtkCheckMenuItem* _tmp3_;
	gboolean _tmp4_;
	gboolean _tmp5_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (item != NULL);
	_tmp0_ = item;
	_tmp1_ = gtk_check_menu_item_get_active (_tmp0_);
	_tmp2_ = _tmp1_;
	ug_settings_set_boolean (UG_SETTINGS_KEY_SCREEN_READER, _tmp2_);
	_tmp3_ = item;
	_tmp4_ = gtk_check_menu_item_get_active (_tmp3_);
	_tmp5_ = _tmp4_;
	if (_tmp5_) {
		{
			gchar** argv = NULL;
			gint argv_length1 = 0;
			gint _argv_size_ = 0;
			gchar** _tmp6_ = NULL;
			gint _tmp7_ = 0;
			gchar** _tmp8_;
			gint _tmp8__length1;
			GPid _tmp9_ = 0;
			UnityGreeter* _tmp10_;
			g_shell_parse_argv ("orca --replace --no-setup --disable splash-window,", &_tmp7_, &_tmp6_, &_inner_error_);
			argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
			argv = _tmp6_;
			argv_length1 = _tmp7_;
			_argv_size_ = argv_length1;
			if (_inner_error_ != NULL) {
				argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
				goto __catch16_g_error;
			}
			_tmp8_ = argv;
			_tmp8__length1 = argv_length1;
			g_spawn_async (NULL, _tmp8_, NULL, G_SPAWN_SEARCH_PATH, NULL, NULL, &_tmp9_, &_inner_error_);
			self->priv->reader_pid = _tmp9_;
			if (_inner_error_ != NULL) {
				argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
				goto __catch16_g_error;
			}
			_tmp10_ = unity_greeter_singleton;
			_tmp10_->orca_needs_kick = TRUE;
			g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, (guint) 1, _____lambda33__gsource_func, g_object_ref (self), g_object_unref);
			argv = (_vala_array_free (argv, argv_length1, (GDestroyNotify) g_free), NULL);
		}
		goto __finally16;
		__catch16_g_error:
		{
			GError* e = NULL;
			GError* _tmp11_;
			const gchar* _tmp12_;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp11_ = e;
			_tmp12_ = _tmp11_->message;
			g_warning ("menubar.vala:482: Failed to run Orca: %s", _tmp12_);
			_g_error_free0 (e);
		}
		__finally16:
		if (_inner_error_ != NULL) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	} else {
		menu_bar_close_pid (self, &self->priv->reader_pid);
	}
}


static guint menu_bar_get_indicator_index (MenuBar* self, IndicatorObject* object) {
	guint result = 0U;
	guint index;
	GList* _tmp0_;
	g_return_val_if_fail (self != NULL, 0U);
	g_return_val_if_fail (object != NULL, 0U);
	index = (guint) 0;
	_tmp0_ = self->priv->indicator_objects;
	{
		GList* io_collection = NULL;
		GList* io_it = NULL;
		io_collection = _tmp0_;
		for (io_it = io_collection; io_it != NULL; io_it = io_it->next) {
			IndicatorObject* _tmp1_;
			IndicatorObject* io = NULL;
			_tmp1_ = _g_object_ref0 ((IndicatorObject*) io_it->data);
			io = _tmp1_;
			{
				IndicatorObject* _tmp2_;
				IndicatorObject* _tmp3_;
				guint _tmp4_;
				_tmp2_ = io;
				_tmp3_ = object;
				if (_tmp2_ == _tmp3_) {
					result = index;
					_g_object_unref0 (io);
					return result;
				}
				_tmp4_ = index;
				index = _tmp4_ + 1;
				_g_object_unref0 (io);
			}
		}
	}
	result = index;
	return result;
}


static IndicatorObject* menu_bar_get_indicator_object_from_entry (MenuBar* self, IndicatorObjectEntry* entry) {
	IndicatorObject* result = NULL;
	GList* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (entry != NULL, NULL);
	_tmp0_ = self->priv->indicator_objects;
	{
		GList* io_collection = NULL;
		GList* io_it = NULL;
		io_collection = _tmp0_;
		for (io_it = io_collection; io_it != NULL; io_it = io_it->next) {
			IndicatorObject* _tmp1_;
			IndicatorObject* io = NULL;
			_tmp1_ = _g_object_ref0 ((IndicatorObject*) io_it->data);
			io = _tmp1_;
			{
				IndicatorObject* _tmp2_;
				GList* _tmp3_ = NULL;
				_tmp2_ = io;
				_tmp3_ = indicator_object_get_entries (_tmp2_);
				{
					GList* e_collection = NULL;
					GList* e_it = NULL;
					e_collection = _tmp3_;
					for (e_it = e_collection; e_it != NULL; e_it = e_it->next) {
						IndicatorObjectEntry* e = NULL;
						e = (IndicatorObjectEntry*) e_it->data;
						{
							IndicatorObjectEntry* _tmp4_;
							IndicatorObjectEntry* _tmp5_;
							_tmp4_ = e;
							_tmp5_ = entry;
							if (_tmp4_ == _tmp5_) {
								result = io;
								_g_list_free0 (e_collection);
								return result;
							}
						}
					}
					_g_list_free0 (e_collection);
				}
				_g_object_unref0 (io);
			}
		}
	}
	result = NULL;
	return result;
}


static void menu_bar_indicator_added_cb (MenuBar* self, IndicatorObject* object, IndicatorObjectEntry* entry) {
	IndicatorObject* _tmp0_;
	guint _tmp1_ = 0U;
	guint index;
	gint pos;
	GList* _tmp2_ = NULL;
	IndicatorObjectEntry* _tmp14_;
	gint _tmp15_;
	IndicatorObjectEntry* _tmp16_;
	IndicatorMenuItem* _tmp17_;
	IndicatorMenuItem* menuitem;
	gint _tmp18_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (object != NULL);
	g_return_if_fail (entry != NULL);
	_tmp0_ = object;
	_tmp1_ = menu_bar_get_indicator_index (self, _tmp0_);
	index = _tmp1_;
	pos = 0;
	_tmp2_ = gtk_container_get_children ((GtkContainer*) self);
	{
		GList* child_collection = NULL;
		GList* child_it = NULL;
		child_collection = _tmp2_;
		for (child_it = child_collection; child_it != NULL; child_it = child_it->next) {
			GtkWidget* child = NULL;
			child = (GtkWidget*) child_it->data;
			{
				GtkWidget* _tmp3_;
				GtkWidget* _tmp4_;
				IndicatorMenuItem* _tmp5_;
				IndicatorMenuItem* menuitem;
				IndicatorMenuItem* _tmp6_;
				IndicatorObjectEntry* _tmp7_;
				IndicatorObject* _tmp8_ = NULL;
				IndicatorObject* child_object;
				IndicatorObject* _tmp9_;
				guint _tmp10_ = 0U;
				guint child_index;
				guint _tmp11_;
				guint _tmp12_;
				gint _tmp13_;
				_tmp3_ = child;
				if (!G_TYPE_CHECK_INSTANCE_TYPE (_tmp3_, TYPE_INDICATOR_MENU_ITEM)) {
					break;
				}
				_tmp4_ = child;
				_tmp5_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp4_, TYPE_INDICATOR_MENU_ITEM, IndicatorMenuItem));
				menuitem = _tmp5_;
				_tmp6_ = menuitem;
				_tmp7_ = _tmp6_->entry;
				_tmp8_ = menu_bar_get_indicator_object_from_entry (self, _tmp7_);
				child_object = _tmp8_;
				_tmp9_ = child_object;
				_tmp10_ = menu_bar_get_indicator_index (self, _tmp9_);
				child_index = _tmp10_;
				_tmp11_ = child_index;
				_tmp12_ = index;
				if (_tmp11_ > _tmp12_) {
					_g_object_unref0 (child_object);
					_g_object_unref0 (menuitem);
					break;
				}
				_tmp13_ = pos;
				pos = _tmp13_ + 1;
				_g_object_unref0 (child_object);
				_g_object_unref0 (menuitem);
			}
		}
		_g_list_free0 (child_collection);
	}
	_tmp14_ = entry;
	_tmp15_ = pos;
	g_debug ("menubar.vala:534: Adding indicator object %p at position %d", _tmp14_, _tmp15_);
	_tmp16_ = entry;
	_tmp17_ = indicator_menu_item_new (_tmp16_);
	g_object_ref_sink (_tmp17_);
	menuitem = _tmp17_;
	_tmp18_ = pos;
	gtk_menu_shell_insert ((GtkMenuShell*) self, (GtkWidget*) menuitem, _tmp18_);
	_g_object_unref0 (menuitem);
}


static void menu_bar_indicator_removed_cb (MenuBar* self, IndicatorObject* object, IndicatorObjectEntry* entry) {
	IndicatorObjectEntry* _tmp0_;
	GList* _tmp1_ = NULL;
	IndicatorObjectEntry* _tmp8_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (object != NULL);
	g_return_if_fail (entry != NULL);
	_tmp0_ = entry;
	g_debug ("menubar.vala:542: Removing indicator object %p", _tmp0_);
	_tmp1_ = gtk_container_get_children ((GtkContainer*) self);
	{
		GList* child_collection = NULL;
		GList* child_it = NULL;
		child_collection = _tmp1_;
		for (child_it = child_collection; child_it != NULL; child_it = child_it->next) {
			GtkWidget* child = NULL;
			child = (GtkWidget*) child_it->data;
			{
				GtkWidget* _tmp2_;
				IndicatorMenuItem* _tmp3_;
				IndicatorMenuItem* menuitem;
				IndicatorMenuItem* _tmp4_;
				IndicatorObjectEntry* _tmp5_;
				IndicatorObjectEntry* _tmp6_;
				_tmp2_ = child;
				_tmp3_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp2_, TYPE_INDICATOR_MENU_ITEM, IndicatorMenuItem));
				menuitem = _tmp3_;
				_tmp4_ = menuitem;
				_tmp5_ = _tmp4_->entry;
				_tmp6_ = entry;
				if (_tmp5_ == _tmp6_) {
					GtkWidget* _tmp7_;
					_tmp7_ = child;
					gtk_container_remove ((GtkContainer*) self, _tmp7_);
					_g_object_unref0 (menuitem);
					_g_list_free0 (child_collection);
					return;
				}
				_g_object_unref0 (menuitem);
			}
		}
		_g_list_free0 (child_collection);
	}
	_tmp8_ = entry;
	g_warning ("menubar.vala:554: Indicator object %p not in menubar", _tmp8_);
}


Background* menu_bar_get_background (MenuBar* self) {
	Background* result;
	Background* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_background;
	result = _tmp0_;
	return result;
}


static void menu_bar_set_background (MenuBar* self, Background* value) {
	Background* _tmp0_;
	Background* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_background);
	self->priv->_background = _tmp1_;
	g_object_notify ((GObject *) self, "background");
}


gboolean menu_bar_get_high_contrast (MenuBar* self) {
	gboolean result;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_high_contrast;
	result = _tmp0_;
	return result;
}


static void menu_bar_set_high_contrast (MenuBar* self, gboolean value) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_high_contrast = _tmp0_;
	g_object_notify ((GObject *) self, "high-contrast");
}


GtkWindow* menu_bar_get_keyboard_window (MenuBar* self) {
	GtkWindow* result;
	GtkWindow* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_keyboard_window;
	result = _tmp0_;
	return result;
}


static void menu_bar_set_keyboard_window (MenuBar* self, GtkWindow* value) {
	GtkWindow* _tmp0_;
	GtkWindow* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_keyboard_window);
	self->priv->_keyboard_window = _tmp1_;
	g_object_notify ((GObject *) self, "keyboard-window");
}


GtkAccelGroup* menu_bar_get_accel_group (MenuBar* self) {
	GtkAccelGroup* result;
	GtkAccelGroup* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_accel_group;
	result = _tmp0_;
	return result;
}


static void menu_bar_set_accel_group (MenuBar* self, GtkAccelGroup* value) {
	GtkAccelGroup* _tmp0_;
	GtkAccelGroup* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_accel_group);
	self->priv->_accel_group = _tmp1_;
	g_object_notify ((GObject *) self, "accel-group");
}


static void _menu_bar_cleanup_unity_greeter_starting_session (UnityGreeter* _sender, gpointer self) {
	menu_bar_cleanup (self);
}


static GObject * menu_bar_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	MenuBar * self;
	GtkSettings* _tmp0_ = NULL;
	struct utsname _tmp1_ = {0};
	const gchar* _tmp2_;
	GtkLabel* _tmp3_;
	GtkLabel* label;
	GtkLabel* _tmp4_;
	GtkMenuItem* _tmp5_;
	GtkMenuItem* hostname_item;
	GtkMenuItem* _tmp6_;
	GtkLabel* _tmp7_;
	GtkMenuItem* _tmp8_;
	GtkMenuItem* _tmp9_;
	GtkMenuItem* _tmp10_;
	GtkMenuItem* _tmp11_;
	GtkLabel* _tmp12_;
	GtkLabel* _tmp13_;
	GtkStyleContext* _tmp14_ = NULL;
	GdkRGBA _tmp15_ = {0};
	GdkRGBA fg;
	GtkLabel* _tmp16_;
	GdkRGBA _tmp17_;
	UnityGreeter* _tmp24_;
	GError * _inner_error_ = NULL;
	parent_class = G_OBJECT_CLASS (menu_bar_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_MENU_BAR, MenuBar);
	_tmp0_ = gtk_settings_get_default ();
	g_object_get ((GObject*) _tmp0_, "gtk-theme-name", &self->priv->default_theme_name, NULL);
	gtk_menu_bar_set_pack_direction ((GtkMenuBar*) self, GTK_PACK_DIRECTION_RTL);
	uname (&_tmp1_);
	_tmp2_ = _tmp1_.nodename;
	_tmp3_ = (GtkLabel*) gtk_label_new (_tmp2_);
	g_object_ref_sink (_tmp3_);
	label = _tmp3_;
	_tmp4_ = label;
	gtk_widget_show ((GtkWidget*) _tmp4_);
	_tmp5_ = (GtkMenuItem*) gtk_menu_item_new ();
	g_object_ref_sink (_tmp5_);
	hostname_item = _tmp5_;
	_tmp6_ = hostname_item;
	_tmp7_ = label;
	gtk_container_add ((GtkContainer*) _tmp6_, (GtkWidget*) _tmp7_);
	_tmp8_ = hostname_item;
	gtk_widget_set_sensitive ((GtkWidget*) _tmp8_, FALSE);
	_tmp9_ = hostname_item;
	gtk_menu_item_set_right_justified (_tmp9_, TRUE);
	_tmp10_ = hostname_item;
	gtk_widget_show ((GtkWidget*) _tmp10_);
	_tmp11_ = hostname_item;
	gtk_menu_shell_append ((GtkMenuShell*) self, (GtkWidget*) _tmp11_);
	_tmp12_ = label;
	gtk_widget_ensure_style ((GtkWidget*) _tmp12_);
	_tmp13_ = label;
	_tmp14_ = gtk_widget_get_style_context ((GtkWidget*) _tmp13_);
	gtk_style_context_get_color (_tmp14_, GTK_STATE_FLAG_NORMAL, &_tmp15_);
	fg = _tmp15_;
	_tmp16_ = label;
	_tmp17_ = fg;
	gtk_widget_override_color ((GtkWidget*) _tmp16_, GTK_STATE_FLAG_INSENSITIVE, &_tmp17_);
	{
		GtkCssProvider* _tmp18_;
		GtkCssProvider* style;
		GtkCssProvider* _tmp19_;
		GtkStyleContext* _tmp20_ = NULL;
		GtkCssProvider* _tmp21_;
		_tmp18_ = gtk_css_provider_new ();
		style = _tmp18_;
		_tmp19_ = style;
		gtk_css_provider_load_from_data (_tmp19_, "* {-GtkWidget-window-dragging: false;}", (gssize) (-1), &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_object_unref0 (style);
			goto __catch17_g_error;
		}
		_tmp20_ = gtk_widget_get_style_context ((GtkWidget*) self);
		_tmp21_ = style;
		gtk_style_context_add_provider (_tmp20_, (GtkStyleProvider*) _tmp21_, (guint) GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
		_g_object_unref0 (style);
	}
	goto __finally17;
	__catch17_g_error:
	{
		GError* e = NULL;
		GError* _tmp22_;
		const gchar* _tmp23_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp22_ = e;
		_tmp23_ = _tmp22_->message;
		g_debug ("menubar.vala:148: Internal error loading menubar style: %s", _tmp23_);
		_g_error_free0 (e);
	}
	__finally17:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (hostname_item);
		_g_object_unref0 (label);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
	}
	menu_bar_setup_indicators (self);
	_tmp24_ = unity_greeter_singleton;
	g_signal_connect_object (_tmp24_, "starting-session", (GCallback) _menu_bar_cleanup_unity_greeter_starting_session, self, 0);
	_g_object_unref0 (hostname_item);
	_g_object_unref0 (label);
	return obj;
}


static void menu_bar_class_init (MenuBarClass * klass) {
	menu_bar_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (MenuBarPrivate));
	GTK_WIDGET_CLASS (klass)->draw = menu_bar_real_draw;
	GTK_WIDGET_CLASS (klass)->get_preferred_height = menu_bar_real_get_preferred_height;
	G_OBJECT_CLASS (klass)->get_property = _vala_menu_bar_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_menu_bar_set_property;
	G_OBJECT_CLASS (klass)->constructor = menu_bar_constructor;
	G_OBJECT_CLASS (klass)->finalize = menu_bar_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), MENU_BAR_BACKGROUND, g_param_spec_object ("background", "background", "background", TYPE_BACKGROUND, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MENU_BAR_HIGH_CONTRAST, g_param_spec_boolean ("high-contrast", "high-contrast", "high-contrast", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MENU_BAR_KEYBOARD_WINDOW, g_param_spec_object ("keyboard-window", "keyboard-window", "keyboard-window", GTK_TYPE_WINDOW, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), MENU_BAR_ACCEL_GROUP, g_param_spec_object ("accel-group", "accel-group", "accel-group", GTK_TYPE_ACCEL_GROUP, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
}


static void menu_bar_instance_init (MenuBar * self) {
	self->priv = MENU_BAR_GET_PRIVATE (self);
	self->priv->_background = NULL;
	self->priv->_high_contrast = FALSE;
	self->priv->_keyboard_window = NULL;
	self->priv->keyboard_pid = (GPid) 0;
	self->priv->reader_pid = (GPid) 0;
}


static void menu_bar_finalize (GObject* obj) {
	MenuBar * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_MENU_BAR, MenuBar);
	_g_object_unref0 (self->priv->_background);
	_g_object_unref0 (self->priv->_keyboard_window);
	_g_object_unref0 (self->priv->_accel_group);
	_g_free0 (self->priv->default_theme_name);
	__g_list_free__g_object_unref0_0 (self->priv->indicator_objects);
	_g_object_unref0 (self->priv->high_contrast_item);
	_g_object_unref0 (self->priv->onscreen_keyboard_item);
	G_OBJECT_CLASS (menu_bar_parent_class)->finalize (obj);
}


GType menu_bar_get_type (void) {
	static volatile gsize menu_bar_type_id__volatile = 0;
	if (g_once_init_enter (&menu_bar_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (MenuBarClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) menu_bar_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (MenuBar), 0, (GInstanceInitFunc) menu_bar_instance_init, NULL };
		GType menu_bar_type_id;
		menu_bar_type_id = g_type_register_static (GTK_TYPE_MENU_BAR, "MenuBar", &g_define_type_info, 0);
		g_once_init_leave (&menu_bar_type_id__volatile, menu_bar_type_id);
	}
	return menu_bar_type_id__volatile;
}


static void _vala_menu_bar_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	MenuBar * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_MENU_BAR, MenuBar);
	switch (property_id) {
		case MENU_BAR_BACKGROUND:
		g_value_set_object (value, menu_bar_get_background (self));
		break;
		case MENU_BAR_HIGH_CONTRAST:
		g_value_set_boolean (value, menu_bar_get_high_contrast (self));
		break;
		case MENU_BAR_KEYBOARD_WINDOW:
		g_value_set_object (value, menu_bar_get_keyboard_window (self));
		break;
		case MENU_BAR_ACCEL_GROUP:
		g_value_set_object (value, menu_bar_get_accel_group (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_menu_bar_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	MenuBar * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_MENU_BAR, MenuBar);
	switch (property_id) {
		case MENU_BAR_BACKGROUND:
		menu_bar_set_background (self, g_value_get_object (value));
		break;
		case MENU_BAR_HIGH_CONTRAST:
		menu_bar_set_high_contrast (self, g_value_get_boolean (value));
		break;
		case MENU_BAR_KEYBOARD_WINDOW:
		menu_bar_set_keyboard_window (self, g_value_get_object (value));
		break;
		case MENU_BAR_ACCEL_GROUP:
		menu_bar_set_accel_group (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



